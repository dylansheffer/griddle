// Creates styles for a root element contained space
// -----------------------------------------------------------------------------
@mixin container () {
  $latest-inset: 0em;
  @each $bp, $bp-data in $g-breakpoints {
    // on each pass through, if we have not hit an "auto" inset then store
    // the inset value for use when we do have an auto inset
    @if map-deep-get($g-breakpoints, #{$bp}, 'inset') != auto {
      $latest-inset: map-deep-get($g-breakpoints, #{$bp}, 'inset');
    }

    @if $bp == "base" {
      margin-left: map-deep-get($g-breakpoints, #{$bp}, 'inset');
      margin-right: map-deep-get($g-breakpoints, #{$bp}, 'inset');
      max-width: $g-max-body-width;
    } @else if $bp == "max-body" {
      width: calc(100% - #{$latest-inset * 2});
      margin-left: auto !important;
      margin-right: auto !important;
    } @else {
      @media (min-width: bp(#{$bp})) {
        width: calc(100% - #{$latest-inset * 2});
        margin-left: map-deep-get($g-breakpoints, #{$bp}, 'inset');
        margin-right: map-deep-get($g-breakpoints, #{$bp}, 'inset');
      }
    }
  }
}

// Creates styles for the griddle visual overlay
// -----------------------------------------------------------------------------
@mixin overlay () {
  $latest-inset: 0em;
  @each $bp, $bp-data in $g-breakpoints {
    // on each pass through, if we have not hit an "auto" inset then store
    // the inset value for use when we do have an auto inset
    @if map-deep-get($g-breakpoints, #{$bp}, 'inset') != auto {
      $latest-inset: map-deep-get($g-breakpoints, #{$bp}, 'inset');
    }

    @if $bp == "base" {
      display: grid;
      grid-template-columns: $g-column-template;
      grid-column-gap: $g-column-gap;
      pointer-events: none;
      z-index: 200; // reasonably safe high z-index
      position: fixed;
      height: 100%;
      top: 0;
      bottom: 0;
      right: map-deep-get($g-breakpoints, #{$bp}, 'inset');
      left: map-deep-get($g-breakpoints, #{$bp}, 'inset');
    } @else {
      @media (min-width: bp(#{$bp})) {
        @if map-deep-get($g-breakpoints, #{$bp}, 'inset') == auto {
          left: 50%;
          right: auto;
          transform: translateX(-50%);
          width: calc(100% - #{$latest-inset * 2});
          max-width: $g-max-body-width;
        } @else {
          left: map-deep-get($g-breakpoints, #{$bp}, 'inset');
          right: map-deep-get($g-breakpoints, #{$bp}, 'inset');
        }
      }
    }
  }
}

// Function to create a percentage width spanning n columns.
// -----------------------------------------------------------------------------
@function span($columns, $args...) {
  @return calcSpan($columns, $args, 'percent');
}

// Function to create a decimal width spanning n columns.
// -----------------------------------------------------------------------------
@function span-decimal($columns, $args...) {
  @return calcSpan($columns, $args, 'decimal');
}

// Shared logic to determine a span value for both percent and decimal spans
// -----------------------------------------------------------------------------
@function calcSpan($columns, $args, $returnValue) {
  $processedArgs: calculateSpanArgs($args, $returnValue);
  $gutters: 0;
  $base-column: 0;
  $base-gutter: 0;
  $modifier: 0;
  $extra_gutters: nth($processedArgs, 1);
  $context: nth($processedArgs, 2);

  // set variables to calculate the proper return value for either
  // span() or span-decimal()
  @if $returnValue == 'percent' {
    $base-column: $g-column;
    $base-gutter: $g-gutter;
    $modifier: 100%; // cast final value to percent
  } @else if $returnValue == 'decimal' {
    $base-column: $g-column-decimal;
    $base-gutter: $g-gutter-decimal;
    $modifier: 1.0000000001; // coerce final value to float, but do not modify
  }

  // determine how many total gutters we need to account for
  @if $columns == 0 {
    $gutters: $extra_gutters;
  } @else {
    $gutters: $extra_gutters + ($columns - 1);
  }

  // return our final value, possibly modified by a provided context
  @if $context != 0 {
    @debug "#{((($columns * $base-column) + ($gutters * $base-gutter)) / $context) * $modifier}";
    @return ((($columns * $base-column) + ($gutters * $base-gutter)) / $context) * $modifier;
  } @else {
    @debug "#{(($columns * $base-column) + ($gutters * $base-gutter)) * $modifier}";
    @return (($columns * $base-column) + ($gutters * $base-gutter)) * $modifier;
  }
}

// helper function to determine if span() args are gutters or context
// -----------------------------------------------------------------------------
@function calculateSpanArgs($args, $returnValue) {
  $extra_gutters: 0;
  $context: 0;

  @if length($args) {
    @for $i from 1 to length($args) + 1 {
      // if the first argument is not a % or a float then assume it's the extra gutters value
      // if it is a % value or a float then it is a context
      @if (
        $i == 1 and type-of(nth($args, $i)) == 'number'
        and getUnit(nth($args, $i)) != '%'
        and round(nth($args, $i)) == nth($args, $i)
      ) {
        $extra_gutters: nth($args, $i);
      } @else if ($i == 1 and type-of(nth($args, $i)) == 'number') {
        $context: nth($args, $i);
      }
      // if there is a 2nd argument it should be the context
      @if ($i == 2 and type-of(nth($args, $i)) == 'number') {
        $context: nth($args, $i);
      }
    }
  }

  @return [$extra_gutters, $context];
}